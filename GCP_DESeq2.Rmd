---
title: "Ros_paper"
output: html_document
date: '2023-02-16'
---

This is a script by Jens Bager Christensen (jbc53@cam.ac.uk) to analyse the injury response of GCPs following neonatal injury. 

```{r}
#Load packages.
library(Seurat)
library(tidyverse)
library(DESeq2)
library(EnhancedVolcano)
library(goseq)

#Defining parameters to test of different resolutions for clustering.
res.range <- c(seq(0.1,2,0.1))
assay <- "SCT"
dims <- 20
reduction <- "pca"

#Defining a function, which clusters a RDS in a range of resolutions, and calculates both the silhouette score and the negative silhouette proportion to determine which resolution is optimal.
clusteringKit <- function(name, assay, dim, res.range, reduction){
  DefaultAssay(name) <- assay
  #using FindNeighbors (Seurat), a KNN based clustering algorithm, to compute a SNN graph, which then can be used to cluster the cells w. their neighbors.
  name <- FindNeighbors(name, dims=1:dim, reduction=reduction)
  for (i in res.range){
    #FindClusters is used to cluster the aforementioned SNN graph by optimising the modularity function. This is carried out for all resolutions in the range of interest.
    name <- FindClusters(name, resolution=i)
  }
DefaultAssay(name) <- assay
  dist.matrix <- dist(x = Embeddings(object = name[[reduction]])[, 1:dim])
 clusters <- paste0(assay,"_snn_res.", res.range)
  getSil <- function(clr) {
    clr <- name@meta.data[[clr]]
    sil <- cluster::silhouette(x = as.numeric(x = as.factor(x = clr)), dist = dist.matrix)
    sil_value <- sil
    return(sil_value)
  }
  
  sls <- lapply(clusters, getSil) #mc.cores = 1)
  sls_median <- sapply(sls, function(x) median(x[,3])) %>% setNames(., res.range)
  sls_neg_prop <- sapply(sls, function(x) sum(x[,3]<0)/length(x[,3])) %>% setNames(., res.range)
  p_list <- lapply(res.range, function(res){
    Idents(name) = name@meta.data[paste0(assay, "_snn_res.",res)]
    DimPlot(name, reduction = "umap", label = TRUE, group.by = paste0(assay, "_snn_res.",res), pt.size =0.3, raster=F)
  })
  return(list(name=name, sls_median=sls_median, sls_neg_prop=sls_neg_prop, dimplots=p_list))
}
```


#This is the script for performing DESeq2 analysis on GCPs to illustrate their response to injury.

The RDS object is read in, which previously has been preprocessed and mapped using CellRanger.
```{r}
#read in the RDS object obtained was described in Pakula et al., 2023.
data <- readRDS(file = "~/../jbc53/data/nep.rna.combined.solo.RDS")

#add cluster annotations to the metadata
data@meta.data <- data@meta.data %>%
  mutate(cluster = Idents(data))

#alter misspelling of a cluster name.
data@meta.data$cluster <- recode_factor(data@meta.data$cluster, "Ependymal_!" = "Ependymal_1")

#inspect the dimplot.
DimPlot(data, label = T, label.box = T, repel = T, group.by = "cluster") & NoLegend() & NoAxes()

#Create a DotPlot of key markers to explain the annotations.
DotPlot(data, group.by = "seurat_clusters", features = c("Hopx", "Gdf10", "Slc1a3", "Ascl1", "Ptf1a", "Tubb3", "Atoh1", "Pax2", "Mki67", "Top2a", "Cx3cr1", "Olig2", "Gpr17", "Foxj1", "Vtn"))
```

Visualising expression of markers of interesting changing with respect to time in GCP clusters.
```{r}
#setting a seed, ensuring consistent clustering
set.seed(123)

#Inspect Atoh1, Barhl1, and Rbfox1 expression in a featureplot and a violin plot to determine which clusters are GCPs
FeaturePlot(data, features = "Atoh1") & NoAxes()
VlnPlot(data, features = "Atoh1", group.by = "cluster", sort = "increasing")
FeaturePlot(data, features = "Barhl1") & NoAxes()
VlnPlot(data, features = "Barhl1", group.by = "cluster", sort = "increasing")
FeaturePlot(data, features = "Rbfox3") & NoAxes()
VlnPlot(data, features = "Rbfox3", group.by = "cluster", sort = "increasing")
#clusters GCP_1, -2, -3, -4, and -5 are deemed to be GCs/GCPs and thus used for further analysis.

#create the subset containing GCPs excluding cells from P1.
Idents(data) <- data@meta.data$cluster
GCP_all <- subset(data, idents = c("GCP_1","GCP_2","GCP_3","GCP_4", "GCP_5")) %>% subset(timepoint != "P1")

#plot expression changing with respect to time of genes of interest. Reordering the levels to make nonIR first.
GCP_all@meta.data$treatment <- factor(GCP_all@meta.data$treatment, levels = c("nonIR", "IR"))
VlnPlot(GCP_all, features = "Cdkn1a", group.by = "timepoint", split.by = "treatment")
VlnPlot(GCP_all, features = "Phlda3", group.by = "timepoint", split.by = "treatment")
VlnPlot(GCP_all, features = "Ass1", group.by = "timepoint", split.by = "treatment")
VlnPlot(GCP_all, features = "Bax", group.by = "timepoint", split.by = "treatment")
VlnPlot(GCP_all, features = "Ano3", group.by = "timepoint", split.by = "treatment")
VlnPlot(GCP_all, features = "Fas", group.by = "timepoint", split.by = "treatment")
```

For the present analysis, the GCs/GCPs are of interest. Thus, these clusters are subsetted, initially only including P2 cells.
```{r}
#subset the GCPs to only include P2 cells.
GCP_p2 <- subset(GCP_all) %>% subset(timepoint == "P2")

#split the object allowing for reintegration.
GCP_p2_list <- SplitObject(GCP_p2, split.by = "orig.ident")

#Re-integrate datasets.
GCP_p2_list <- lapply(X = GCP_p2_list, FUN = function(x) {
  x <- NormalizeData(x)
  x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 3000)
})

#select features that are repeatedly variable across datasets for integration.
features.GCP_p2 <- SelectIntegrationFeatures(object.list = GCP_p2_list)
rna.anchors.GCP_p2 <- FindIntegrationAnchors(object.list = GCP_p2_list, anchor.features = features.GCP_p2)

#this command creates an 'integrated' data assay, k.weight set to 50 to accommodate the small subset.
GCP_p2 <- IntegrateData(anchorset = rna.anchors.GCP_p2, k.weight = 50)

#regress out CC, mitrochondrial -, gene reads, and sequencing depth.
GCP_p2 <- SCTransform(GCP_p2, vars.to.regress = c("percent.mt", "CC.Difference", "nFeature_RNA", "nCount_RNA"))

#run PCA and UMAP w. parameters previously used.
GCP_p2 <- RunPCA(GCP_p2, features = GCP_p2@assays$integrated@var.features, npcs = 100)
GCP_p2 <- RunUMAP(GCP_p2, dims = 1:40, n.neighbours = 30L, seed.use = 888, repulsion.strength = 0.1, min.dist = 0.5, n.epochs = NULL)

#Visualise the data.
DimPlot(GCP_p2, label = T, label.box = T, repel = T) + ggtitle("UMAP of subsetted GCPs") & NoLegend() & NoAxes()

#Recluster the data trying out different clustering resolutions to figure out an optimal resolution.
GCP_p2_combined <- clusteringKit(GCP_p2, assay="SCT", dim=30, res.range=seq(0.1, 3, 0.1), reduction="pca")

#plot to find the highest silhouette score w. low negative silhouette proportion
plot(GCP_p2_combined$sls_median~seq(0.1,3,0.1), type = "l", ylab = "Silhouette score") & plot(GCP_p2_combined$sls_neg_prop~seq(0.1,3,0.1), type = "l", ylab = "Negative silhouette proportion score")
#optimal resolution is seemingly around 0.7 - 0.8. The resolutions are evaluated for biological relevance to determine the actual optimal resolution.

#rename the Seurat objects
GCP_p2 <- GCP_p2_combined$name

#Plot with the new resolutions
DimPlot(GCP_p2, label = T, label.box = T, repel = T, group.by = "SCT_snn_res.0.8") + ggtitle("Cells from GC/GCP clusters from P2") & NoLegend() & NoAxes()
DimPlot(GCP_p2, label = F, label.box = T, repel = T, group.by = "timepoint", pt.size = 2) + ggtitle("Cells from GC/GCP clusters from P2") & NoAxes()
DimPlot(GCP_p2, label = F, label.box = T, repel = T, group.by = "treatment", pt.size = 2) + ggtitle("Cells from GC/GCP clusters from P2") & NoAxes()
DimPlot(GCP_p2, label = F, label.box = T, repel = T, group.by = "cluster", pt.size = 2) + ggtitle("Cells from GC/GCP clusters from P2") & NoAxes()

#See the Atoh1, Barhl1, and Rbfox3 expression in the subset.
FeaturePlot(GCP_p2, features = c("Atoh1", "Barhl1", "Rbfox3")) & NoAxes()
VlnPlot(GCP_p2, features = c("Atoh1", "Barhl1", "Rbfox3"), group.by = "cluster", sort = "increasing")
```


Performing the pseudobulk DEG analysis on only cells from P2, trying to capture the injury signal. Additionally, this matches the timepoint of the other experiments.
```{r}
#Choose the RDS object containing the cell of interest.
GCP_p2_deseq2 <- GCP_p2 

#make a sample column in the meta data.
GCP_p2_deseq2@meta.data$samples <- paste0(GCP_p2_deseq2$orig.ident)

#Aggregate the count matrices from the RDS object.
GCP_p2_cts <- AggregateExpression(GCP_p2_deseq2, group.by = c("samples", "treatment"),
                           assays = "RNA",
                           slot = "counts",
                           return.seurat = F)

#ensure the active assay is the RNA assay.
GCP_p2_cts <- GCP_p2_cts$RNA

#create a tibble containing the meta data necessary for performing the correct comparisons.
GCP_p2_colData <- tibble(samples = colnames(GCP_p2_cts))
GCP_p2_colData <- GCP_p2_colData %>% mutate(condition = ifelse(grepl('non', samples), 'nonIR', 'IR')) %>% column_to_rownames(var = 'samples')

#create an object suitable for a DESeq2 analysis.
GCP_p2_dds <- DESeqDataSetFromMatrix(countData = GCP_p2_cts,
                              colData = GCP_p2_colData,
                              design = ~ condition)

#remove too lowly expressed genes.
GCP_p2_keep <- rowSums(counts(GCP_p2_dds)) >= 10
GCP_p2_dds <- GCP_p2_dds[GCP_p2_keep,]

#perform the actual DESeq2 analysis.
GCP_p2_dds <- DESeq(GCP_p2_dds)

#identify the results of interest and save it in a variable.
resultsNames(GCP_p2_dds)
GCP_p2_res <- results(GCP_p2_dds, name = "condition_nonIR_vs_IR")

#visualise the results of the DESeq2 analysis in a volcano plot.
EnhancedVolcano(GCP_p2_res, lab = row.names(GCP_p2_res), x = 'log2FoldChange', y = 'padj', pCutoff = 0.05, FCcutoff = 0.5, labSize = 4, cutoffLineType = "blank", xlab = "Log fold-change", ylab = "-Log adjusted p-val" ,   colAlpha = 1, legendPosition = 'right', legendLabSize = 12, legendIconSize = 4.0, drawConnectors = T) & NoLegend()

#save csv of the DESeq2 analysis
#write.csv(GCP_p2_res, file = "ROS_paper/GCP/GCP_p2_DESeq2.csv")
```


Performing GO term analysis to see, if any ROS related pathways are upregulated in the IR cells
```{r}
#restructuring the DESeq2 results making it fit for GO term analysis.
GCP_p2_res_go <- GCP_p2_res %>% as.tibble() %>% transform(gene = row.names(GCP_p2_res))

#identify the genes which are significantly differentially expressed in the IR cells. 
GCP_p2_isSigGene <- GCP_p2_res_go$padj < 0.05 & !is.na(GCP_p2_res_go$padj) & GCP_p2_res_go$log2FoldChange < -0.5
GCP_p2_genes <- as.integer(GCP_p2_isSigGene)
names(GCP_p2_genes) <- GCP_p2_res_go$gene

#calculate a probability weight function for the significantly DE genes in IR cells.
GCP_p2_pwf <- nullp(GCP_p2_genes, "mm8", "geneSymbol")

#perform the goseq analysis.
GCP_p2_goResults <- goseq(GCP_p2_pwf, "mm8","geneSymbol", test.cats=c("GO:BP"))

#visualise the top 10 overrepresented GO terms.
GCP_p2_goResults %>% 
    top_n(10, wt=-over_represented_pvalue) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Hits (%)", y="GO term", colour="p value", size="Count", title = "GO term analysis for IR cells from P2 of GCP clusters") + theme_bw()


#visualisation of selected GO terms.
GCP_p2_goResults %>% 
    subset(category %in% c("GO:0072331", "GO:0006915", "GO:0006950", "GO:0008630", "GO:0042771", "GO:0071478", "GO:0006974", "GO:0045926", "GO:0071479", "GO:0031571", "GO:0072593")) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Hits (%)", y="GO term", colour="p value", size="Count", title = "GO term analysis for IR cells from P2 of GCP clusters") + theme_bw()

#look a stress-related GO terms to see if any of these are significantly overrepresented.
GCP_p2_goResults[grep("stress", GCP_p2_goResults$term), ]

#Write a csv of the GO term results.
#write.csv(GCP_p2_goResults, file = "ROS_paper/GCP/GCP_P2_GO_term.csv")
```

Performing the GO term analysis on the DEGs upregulated in nonIR cells.
```{r}
#restructuring the DESeq2 results making it fit for GO term analysis.
GCP_p2_res_go <- GCP_p2_res %>% as.tibble() %>% transform(gene = row.names(GCP_p2_res))

#identify the genes which are significantly differentially expressed in nonthe IR cells.
GCP_p2_isSigGene_nonIR <- GCP_p2_res_go$padj < 0.05 & !is.na(GCP_p2_res_go$padj) & GCP_p2_res_go$log2FoldChange > 0.5
GCP_p2_genes_nonIR <- as.integer(GCP_p2_isSigGene_nonIR)
names(GCP_p2_genes_nonIR) <- GCP_p2_res_go$gene

#calculate a probability weight function for the significantly DE genes in IR cells.
GCP_p2_pwf_nonIR <- nullp(GCP_p2_genes_nonIR, "mm8", "geneSymbol")

#perform the goseq analysis.
GCP_p2_goResults_nonIR <- goseq(GCP_p2_pwf_nonIR, "mm8","geneSymbol", test.cats=c("GO:BP"))

#visualise the top 10 overrepresented GO terms.
GCP_p2_goResults_nonIR %>% 
    top_n(10, wt=-over_represented_pvalue) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Hits (%)", y="GO term", colour="p value", size="Count", title = "GO term analysis for nonIR cells from P2 of GCP clusters") + theme_bw()

#visualisation of selected GO terms.
GCP_p2_goResults_nonIR %>% 
    subset(category %in% c("GO:0006066", "GO:0006694", "GO:0006695", "GO:0006629", "GO:0044255", "GO:0006644")) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Hits (%)", y="GO term", colour="p value", size="Count", title = "GO term analysis for nonIR cells from P2 of GCP clusters") + theme_bw()

#look a stress-related GO terms to see if any of these are significantly overrepresented.
GCP_p2_goResults_nonIR[grep("stress", GCP_p2_goResults_nonIR$term), ]

#Write a csv of the GO term results
#write.csv(GCP_p2_goResults_nonIR, file = "ROS_paper/GCP/GCP_P2_GO_term_nonIR.csv")
```

Doing the analysis using P3 + P5 cells to compare early and later injury response.
```{r}
#setting a seed, ensuring consistent clustering.
set.seed(123)

#subset the clusters annotated to be GCPs which are not from P1 or P2.
GCP_late <- subset(data, idents = c("GCP_1","GCP_2","GCP_3","GCP_4", "GCP_5"))
GCP_late <- subset(GCP_late, timepoint != c("P1"))
GCP_late <- subset(GCP_late, timepoint != c("P2"))



#split the object allowing for reintegration.
GCP_late_list <- SplitObject(GCP_late, split.by = "orig.ident")


# Re-integrate datasets
GCP_late_list <- lapply(X = GCP_late_list, FUN = function(x) {
  x <- NormalizeData(x)
  x <- FindVariableFeatures(x, selection.method = "vst", nfeatures = 3000)
})


# select features that are repeatedly variable across datasets for integration.
features.GCP_late <- SelectIntegrationFeatures(object.list = GCP_late_list)
rna.anchors.GCP_late <- FindIntegrationAnchors(object.list = GCP_late_list, anchor.features = features.GCP_late)

#this command creates an 'integrated' data assay.
GCP_late <- IntegrateData(anchorset = rna.anchors.GCP_late)

#regress out CC, mitrochondrial -, gene reads, and sequencing depth.
GCP_late <- SCTransform(GCP_late, vars.to.regress = c("percent.mt", "CC.Difference", "nFeature_RNA", "nCount_RNA"))

#run PCA and UMAP w. parameters previously used.
GCP_late <- RunPCA(GCP_late, features = GCP_late@assays$integrated@var.features, npcs = 100)
GCP_late <- RunUMAP(GCP_late, dims = 1:40, n.neighbours = 30L, seed.use = 888, repulsion.strength = 0.1, min.dist = 0.5, n.epochs = NULL)

#Visualise the data.
DimPlot(GCP_late, label = T, label.box = T, repel = T) + ggtitle("UMAP of subsetted GCs/GCPs") & NoLegend() & NoAxes()

#Recluster the data trying out different clustering resolutions to figure out an optimal resolution.
GCP_late_combined <- clusteringKit(GCP_late, assay="SCT", dim=30, res.range=seq(0.1, 3, 0.1), reduction="pca")

#plot to find the highest silhouette score w. low negative silhouette proportion.
plot(GCP_late_combined$sls_median~seq(0.1,3,0.1), type = "l", ylab = "Silhouette score") & plot(GCP_late_combined$sls_neg_prop~seq(0.1,3,0.1), type = "l", ylab = "Negative silhouette proportion score")
#optimal resolution is seemingly around 0.2-0.3. The resolutions are evaluated for biological relevance to determine the actual optimal resolution.

#rename the Seurat objects.
GCP_late <- GCP_late_combined$name

#Plot with the new resolutions
DimPlot(GCP_late, label = T, label.box = T, repel = T, group.by = "SCT_snn_res.0.3") + ggtitle("Cells from GCP clusters from P3 and P5") & NoLegend() & NoAxes()
DimPlot(GCP_late, label = F, label.box = T, repel = T, group.by = "timepoint", pt.size = 2) + ggtitle("Cells from GCP clusters from P3 and P5") & NoAxes()
DimPlot(GCP_late, label = F, label.box = T, repel = T, group.by = "treatment", pt.size = 2) + ggtitle("Cells from GCP clusters from P3 and P5") & NoAxes()
DimPlot(GCP_late, label = F, label.box = T, repel = T, group.by = "cluster", pt.size = 2) + ggtitle("Cells from GCP clusters from P3 and P5") & NoAxes()
```


Performing the pseudobulk DEG analysis on cells from P3 + P5 to capture later biological responses to injury.
```{r}
#Choose the RDS object containing the cell of interest.
GCP_late_deseq2 <- GCP_late 

#make a sample column in the meta data.
GCP_late_deseq2@meta.data$samples <- paste0(GCP_late_deseq2$orig.ident)

#Aggregate the count matrixes from the RDS object.
GCP_late_cts <- AggregateExpression(GCP_late_deseq2, group.by = c("samples", "treatment"),
                           assays = "RNA",
                           slot = "counts",
                           return.seurat = F)

#ensure the active assay is the RNA assay.
GCP_late_cts <- GCP_late_cts$RNA

#create a tibble containing the meta data necessary for performing the correct comparisons.
GCP_late_colData <- tibble(samples = colnames(GCP_late_cts))
GCP_late_colData <- GCP_late_colData %>% mutate(condition = ifelse(grepl('non', samples), 'nonIR', 'IR')) %>% column_to_rownames(var = 'samples')

#create an object suitable for a DESeq2 analysos.
GCP_late_dds <- DESeqDataSetFromMatrix(countData = GCP_late_cts,
                              colData = GCP_late_colData,
                              design = ~ condition)

#remove too lowly expressed genes.
GCP_late_keep <- rowSums(counts(GCP_late_dds)) >= 10
GCP_late_dds <- GCP_late_dds[GCP_late_keep,]

#perform the actual DESeq2 analysis.
GCP_late_dds <- DESeq(GCP_late_dds)

#identify the results of interest and save it in a variable.
resultsNames(GCP_late_dds)
GCP_late_res <- results(GCP_late_dds, name = "condition_nonIR_vs_IR")

#visualise the results of the DESeq2 analysis in a volano plot.
EnhancedVolcano(GCP_late_res, lab = row.names(GCP_late_res), x = 'log2FoldChange', y = 'padj', pCutoff = 0.05, FCcutoff = 0.5, labSize = 4, cutoffLineType = "blank", xlab = "Log fold-change", ylab = "-Log adjusted p-val" ,   colAlpha = 1, legendPosition = 'right', legendLabSize = 12, legendIconSize = 4.0, drawConnectors = T) & NoLegend()

#save csv of the DESeq2 analysis.
#write.csv(GCP_late_res, file = "ROS_paper/GCP/GCP_P3_P5_DESeq2.csv")
```


Performing GO term analysis to see, if any ROS related pathways are upregulated in the IR cells
```{r}
#restructuring the DESeq2 results making it fit for GO term analysis
GCP_late_res_go <- GCP_late_res %>% as.tibble() %>% transform(gene = row.names(GCP_late_res))

#identify the genes which are significantly differentially expressed in the IR cells. 
GCP_late_isSigGene <- GCP_late_res_go$padj < 0.05 & !is.na(GCP_late_res_go$padj) & GCP_late_res_go$log2FoldChange < -0.5
GCP_late_genes <- as.integer(GCP_late_isSigGene)
names(GCP_late_genes) <- GCP_late_res_go$gene

#calculate a probability weight function for the significantly DE genes in IR cells.
GCP_late_pwf <- nullp(GCP_late_genes, "mm8", "geneSymbol")

#perform the goseq analysis.
GCP_late_goResults <- goseq(GCP_late_pwf, "mm8","geneSymbol", test.cats=c("GO:BP"))

#visualise the top 10 overrepresentated GO terms.
GCP_late_goResults %>% 
    top_n(10, wt=-over_represented_pvalue) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Hits (%)", y="GO term", colour="p value", size="Count", title = "GO term analysis for IR cells from P3 and P5 of GCP clusters") + theme_bw()

#visualisation of selected GO terms.
GCP_late_goResults %>% 
    subset(category %in% c("GO:0072332", "GO:0008630", "GO:0045429", "GO:0010212", "GO:0007095", "GO:0001558")) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Hits (%)", y="GO term", colour="p value", size="Count", title = "GO term analysis for IR cells from P3 and P5 of GCP clusters") + theme_bw()

#look a stress-related GO terms to see if any of these are significantly overrepresented.
GCP_late_goResults[grep("stress", GCP_late_goResults$term), ]

#Write a csv of the GO term results.
#write.csv(GCP_late_goResults, file = "ROS_paper/GCP/GCP_P3_P5_GO_term.csv")
```


Performing the same GO term analysis for DEGs upregulated in the nonIR cells.
```{r}
#restructuring the DESeq2 results making it fit for GO term analysis
GCP_late_res_go <- GCP_late_res %>% as.tibble() %>% transform(gene = row.names(GCP_late_res))

#identify the genes which are significantly differentially expressed in the nonIR cells.
GCP_late_isSigGene_nonIR <- GCP_late_res_go$padj < 0.05 & !is.na(GCP_late_res_go$padj) & GCP_late_res_go$log2FoldChange > 0.5
GCP_late_genes_nonIR <- as.integer(GCP_late_isSigGene_nonIR)
names(GCP_late_genes_nonIR) <- GCP_late_res_go$gene

#calculate a probability weight function for the significantly DE genes in nonIR cells.
GCP_late_pwf_nonIR <- nullp(GCP_late_genes_nonIR, "mm8", "geneSymbol")

#perform the goseq analysis.
GCP_late_goResults_nonIR <- goseq(GCP_late_pwf_nonIR, "mm8","geneSymbol", test.cats=c("GO:BP"))

#visualise the top 10 overrepresented GO terms
GCP_late_goResults_nonIR %>% 
    top_n(10, wt=-over_represented_pvalue) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Hits (%)", y="GO term", colour="p value", size="Count", title = "GO term analysis for nonIR cells from P3 and P5") + theme_bw()

#visualisation of selected GO terms.
GCP_late_goResults_nonIR %>% 
    subset(category %in% c("GO:0006650", "GO:0044255", "GO:0006629", "GO:0035788")) %>% 
    mutate(hitsPerc=numDEInCat*100/numInCat) %>% 
    ggplot(aes(x=hitsPerc, 
               y=term, 
               colour=over_represented_pvalue, 
               size=numDEInCat)) +
        geom_point() +
        expand_limits(x=0) +
        labs(x="Hits (%)", y="GO term", colour="p value", size="Count", title = "GO term analysis for nonIR cells from P3 and P5 of GCP positive clusters") + theme_bw()

#look a stress-related GO terms to see if any of these are significantly overrepresented.
GCP_late_goResults_nonIR[grep("stress", GCP_late_goResults_nonIR$term), ]

#Write a csv of the GO term results
#write.csv(GCP_late_goResults_nonIR, file = "ROS_paper/GCP/GCP_P3_P5_GO_term_nonIR.csv")
```

